# Chapter 5. RAG 활용하기

## 5.1 텍스트를 숫자로 바꾸는 텍스트 임베딩

* RAG 의 기본 원리

1. 1단계: Document Loader를 통해서 문서를 Document 객체 형태로 로드
1. 2단계: Text Splitter를 통해 여러 청크로 분할
1. 3단계: 분할한 데이터를 벡터 DB에 저장
1. 4단계: 사용자 질문에 답할 근거를 DB에서 검색
1. 5단계: 검색한 데이터를 LLM에 전달하여 답변을 얻음

* 3단계, 4단계에서 임베딩을 활용

### 임베딩이란?

* 텍스트를 수치로 변환하는 작업
* 텍스트를 수치로 바뀌기 위해서는 대량의 텍스트로 사전 학습된 모델이 활용되는데 대표 모델로 BERT가 있음
* 문장을 임베딩하기 위해서는 문장 임베딩에 특화하여 파인 튜닝한 Sentence-BERT를 활용
* Sentence-BERT에 대해서 좀 더 찾아보자.
* Sentence-BERT를 활용하여 특정 문장이 다른 문장과 어떻게 비슷한지, 문장에서 사용된 단어가 어떤 맥락으로 쓰인 것인지 수치로 나타낼 수 있음

### open-source, closed source

* 오픈 소스는 허딩페이스(https://huggingface.co/)에서 쉽게 찾을 수 있음
* 오픈 소스의 경우는 사용하는게 쉽지 않다.
* closed source는 여러 기업에서 API 형태로 제공(사용하기 쉽다)
* 대신 돈을 내야 한다.
* 기업에서 사용할 때는 보안 등의 이슈로 closed source를 활용하긴 쉽지 않다.


## 5.2 문서 벡터 저장소, Vector Stores

* 백터 DB는 말 그대로 여러 문서의 청크를 임베딩하여 얻어낸 임베딩 벡터의 데이터베이스
* 기존 RDB와 차이점
   1. 비정형 데이터를 저장하는 데 특화
   2. 데이터 조회 방식이 다름
      * RDB: SQL 쿼리 기반으로 사용자가 찾으려는 정형 데이터의 정확한 행과 열을 추춪하여 정보를 조회
      * 백터 DB: 텍스트나 이미지를 검색할 때 일치하는 것이 아닌 비슷한 것을 요구하는 필요가 많다.
        * SPTAG, HNSW 등의 ANN 알고리즘을 활용해서 탐색

### 벡터 DB의 종류

#### 1. 순수 벡터 데이터베이스

* Chroma, Weaviate, Qdrant 등의 오픈소스와 Pinecone, ziliz 와 같은 상용 툴이 있다.
* 백터 DB로써 갖춰야 할 기본적인 기능들이 가장 많이 발달
* 기존 RDB와 결합이 힘듬

#### 2. 텍스트 전용 데이터베이스

* Elasticsearch, openSearch, Apache Lucene, Solr
* 백터 검색을 위한 유사도 계산에 최적화되지 않음
* 추가적인 모듈이 필요

#### 3. 벡터 라이브러리

* 벡터의 유사도 계산이나 클러스터링을 위한 라이브러리
* FAISS
* DB 로써의 기능이 부실

#### 4. 백터 기능이 추가된 NoSQL

* mongodb, neo4j, redis
* 벡터 기능이 추가된지 얼마 안되어서 기능적인 검증이 더 필요

#### 5. 벡터 저장 및 검색 가능한 SQL DB

* 기존의 몇몇 DB에서 벡터 저장이 가능하도록 기능을 제공
* RDB는 정형화된 데이터를 저장하기 위한 용도 이기 때문에 최적화되어 있지 않다.


### Chroma DB란?

* 오픈 소스 벡터 DB
* 순서 벡터 DB이기 때문에 벡터 임베딩을 다루기 위해 필요한 다양한 기능을 제공
* 다른 벡터 DB에 비해 사용하기 쉽다.

## 5.3 RAG의 문서 검색기, Retriever

* 사용자의 질문과 답변 근거가 될 문서의 연결이 왜 중요한 문제인지 두 가지 측명에서 살펴보자
   1. 사용자의 질문을 어떻게 해설할 것인가?
      * RAG 시스템을 구축화면서 가장 먼저 고려해야 하는 것은 사용자 행동 예측
      * RAG를 실제 사람이 답변하는 것처럼 작동하게 하려면, 사용자의 질문을 다양한 방식으로 해석하여 답변하도록 만들어야 한다.

   2. 답변의 근거가 될 문서를 어떻게 얼마나 가져올 것인가?
      * RAG는 사용자의 질문과 유사한 청크를 벡터 DB 검색으로 찾아낸다.
      * 사용자의 질문과 유사한 청크가 벡터 DB 내에 100개가 있다면 구중에서 몇 개를 가져올지 정해야 한다.
      * 유사도 높은 N개를 가져와야 하는데 이 부분에 대한 판단이 중요

* RAG의 검색 단계는 많은 고려 사항을 검토하여 최적의 파라미터를 찾아내야 하는 단계
* 랭체인에서는 이 과정을 보조하는 다양한 모듈들을 갖고 있는데 이를 Retriever(검색기)라고 한다.

### 백터 DB 기반의 Retriever

* 가장 기초가 되는 형태
* 벡터 DB는 문장 간 임베딩 유사도 계산 기능을 내장하고 있기 때문에, 랭체인을 결합하지 않더라도 검색 기능을 구착할 수 있다.
* 랭체인의 Retriever 모듈을 통해 백테 DB를 결합하면 더 쉽고 세밀한 검색 기능을 만들 수 있다.




